<?xml version="1.0"?>

<!DOCTYPE document SYSTEM "dtd/document-v10.dtd">

<document>
  <header>
    <title>Avalon Framework - Guide - COP in Avalon</title>
    <authors>
      <person name="Berin Loritsch" email="bloritsch@apache.org"/>
      <person name="Leo Simons" email="leosimons@apache.org"/>
    </authors>
  </header>
  <body>
    <s1 title="Components in Avalon">
      <p>
        At the core of the Avalon framework is the Component. We define it as "a
        passive entity that performs a specific role". This is important to grasp
        because it requires a specific way of thinking.
      </p>
      <s2 title="A passive API">
        <p>
          A passive entity must employ a passive API. A passive API is one that is
          acted upon, versus one that acts itself. See the
          <link href="guide-patterns-ioc.html">Inversion of Control</link> pattern
          for an explanation.
        </p>
      </s2>
      <s2 title="A specific Role">
        <p>
          The concept of roles come from the theater.  A play, musical,
          or movie will have a certain number of roles that actors play.
          Although there never seems to be a shortage of actors, there
          are a finite number of roles.  I am not going to make reference
          to different types of roles at this point, but simply bring
          the concept to light.  The function or action of a role is
          defined by it's script.
        </p>
        <p>
          We are introducing this concept now because you need to have it
          in mind when you are designing your system architecture.  Think
          of the different roles in your system, and you will have your
          "cast" of components so to speak.
        </p>
        <p>
          For each role, you need to specify it's script, or interface to
          the rest of the system.  To be honest the interface is not enough.
          There are specific contracts that you must define and keep in mind
          when you specify your interfaces.  In other words, what users
          of the Component must provide, and what the Component produces.
          When the interface and contract are defined, you can work on your
          implementation.
        </p>
      </s2>
    </s1>


    <s1 title="The Component">
      <p>
        John Donne wrote, "No man is an island." to communicate that we
        are all interdependent.  The same is true for the Component.  That
        is why there are different concerns regarding the Component.  In
        the section on roles we specified one of the concerns: the role.
        The concerns directly supported by the Avalon Framework are:
        configuration, external component use, management, and execution.
      </p>
      <note>
        We used to have an marker interface Component. This has been deprecated
        because requiring all components extend this interface makes
        integrating Avalon with other component systems like
        <link href="http://www.corba.org">CORBA</link> very cumbersome.
      </note>
      <p>
        As you might of guessed, each one of these concerns has a separate
        interface that describes that concern.  We will delve deeper into
        the interfaces and the reasoning behind them in other sections.  It
        is important to know the order of precedence for the concerns so
        that you know the overall contracts of how they are put together.
      </p>
      <ol>
        <li>
          <strong>Configurable:</strong> marks an object that can be configured.
        </li>
        <li>
          <strong>Composable:</strong> marks an object that uses Components.
        </li>
        <li>
          <strong>Initializable:</strong> marks an object that can be initialized.
        </li>
        <li>
          <strong>Disposable:</strong> marks an object that can be disposed.
        </li>
        <li>
          <strong>Stoppable:</strong> marks an object that can be started and stopped.
        </li>
      </ol>
      <p>
        The contract surrounding this order means that the methods defined
        by each of those interfaces are called in a specific order by the object
        that created the Component.  Each interface represents a narrow view
        of the Component or object being controlled.
      </p>
      <note>
        Notice that each interface is separate from Component, so you can use
        them for simple objects.
      </note>
    </s1>

    <s1 title="The Composable"> 
      <p>
        In Avalon, Composable is defined as an active entity that controls
        or uses Components.  Its best analogy is that of a musical composer.
        The musical composer chooses what instruments (Components) by their
        role in the symphony (system) and tells them which notes to play.
      </p> 
      <p>
        The Avalon Composable follows the principles of Inversion of Control,
        and is assigned a Component Manager.  Within this section we will
        discuss how to look up specific Components, and then how to prepare
        the ComponentManager for the Composable.
      </p>
      <note>
        The Composable has a specific contract that must be enforced for security
        reasons.  The ComponentManager must only be set once.  That means that
        the <code>compose</code> method must ignore all subsequent
        requests to set the ComponentManager after it is successfully set.
      </note>
    </s1>

    <s1 title="Finding your Component">
      <s2 title="The Component Manager">
        <p>
          For the majority of all cases, you will need to use the ComponentManager
          get the instance of the Component you need.  If you recall the discussion
          on Component Roles in the Component documentation, you already have
          a head start.  In Avalon, Roles are defined by the work interface a
          Component has.  A work interface is different from any other interface
          because it is the interface that defines the Component's Role.  Composable
          and Component are concern interfaces because they address specific
          concerns about the Component.
        </p>
        <p>
          The ComponentManager has one method to retrieve all of your Components.
          The <code>lookup</code> method will look up the Component based on the
          fully qualified name (FQN) of the work interface (Role).  It is important
          to realize that the ComponentManager returns Components, and therefore
          you must recast the Component to the Role you need.  See the following
          example:
        </p>
        <source>
final MyComponent component = (MyComponent)manager.
     lookup( "com.mycompany.myproject.MyComponent" );
        </source>
        <p>
          It is important to note that Role is not the same thing as functional
          equivalence.  In other words, if you have a MailSpooler that is functionally
          equivalent to a FileStore (they do the same thing), it does not mean that
          they perform the same Role.  The FileStore is used to store objects to
          files, and the MailSpooler is used to temporarily store messages until
          they are sent.  Thus they are separate roles.  Sometimes you need to
          create a new interface name that does nothing more than allow access to 
          alternate roles who have the same role.
        </p>
      </s2>
      <s2 title="The Component Selector">
        <p>
          Sometimes you will have several Components that function in the same role.
          For those cases, you will use the ComponentSelector to choose the exact
          one you need.  The best way to describe its proper use is the scenario
          described here.  You have several formatters that have the same Role:
          to take an input document and format it according to the rules in the
          individual Component implementations.  One formatter may take a text file
          and remove all tabs and replace them with four spaces.  Another formatter
          may reverse the formerly mentioned one.  Yet another takes the text file
          and formats it for a canvas object.  For the Composable, it makes no difference
          what the implementation does--just that it formats the text.
        </p>
        <p>
          Using the processing chain example in the previous paragraph, we realize
          the unsuitability of the ComponentManager for getting the right Component.
          The Component addresses the concern of one Component per role.  Fortunately,
          the ComponentSelector is a Component.  That means we use the ComponentManager
          to lookup the ComponentSelector.  The ComponentSelector is designed to choose
          the specific Component out of many that perform the <strong>same</strong>
          Role.  The following code will help:
        </p>
        <source>
final ComponentSelector selector = (ComponentSelector)manager.
    lookup( "org.mycompany.myproject.FormatterSelector" );
final Formatter formatter = (Formatter)selector.select( myURL );
        </source>
        <p>
          The selector does not discriminate against lookup keys.  In that respect it
          acts much like a hashtable lookup.  Keep in mind that the implementation of the
          selector does not limit you to a hashtable lookup--you can dynamically
          instantiate objects as well.  It takes an object (a hint), and returns the
          specific Component based on that hint.
        </p>

	<note>
	Discussions are currently taking place about the ComponentSelector interface and
	concept. It might be deprecated at some point in the future. There are indications
	that usage of the ComponentSelector is only required when an application is
	badly designed.
	</note>
      </s2>
      <s2 title="When you are done with the Component">
        <p>
	  Both the ComponentManager and the ComponentSelector require you to
	  release your Component when you are done with it.  The method used
	  to do this is "release".  One way of handling this is to use the
	  try/catch/finally construct.  For your convenience, the following
	  code can help:
	</p>
	<source>
MyComponent component = null;

try
{
    component = (MyComponent) manager.lookup("org.mycom.MyComponent");
    component.myMethod();
}
catch (Exception e)
{
    getLogger().debug("Error using MyComponent", e);
}
finally
{
    if (component != null) manager.release(component);
}
	</source>
	<p>
	  The reason for this is so that smart Component Managers that
	  select Components from a pool can properly manage the resources.
	</p>
      </s2>
    </s1>

    <s1 title="Populating the ComponentManager">
      <p>
        It is the responsibility of the entity that creates the Composable to give it a
        ComponentManager with all of the Roles populated.  If you create your own
        implementations of the ComponentManager and ComponentSelector then you have
        the liberty of deciding how to populate them.  Keep in mind that there are
        default implementations included, and you should model their behavior as
        much as possible.
      </p>
      <s2 title="DefaultComponentManager">
        <p>
          The DefaultComponentManager is nothing more than a Hashtable lookup of roles
          and Components.  It even gives you the method <code>put</code> to populate
          the ComponentManager.  One feature of the DefaultComponentManager is that
          it can cascade.  In other words, if the role is not found in this ComponentManager,
          the default implementation will look in the parent ComponentManager.
        </p>
        <p>
          For the paranoid developer, the Cascading feature of the ComponentManager
          can be seen as a security hole as opposed to a usability enhancement.  You
          are free to create your own implementation that does not use the Cascading
          feature--but you have to manually populate it with anything that would
          have been in the parent ComponentManager that your child Composable needs.
          Truth be told, there is very little risk due to the set-once contract for
          ComponentManagers.  The method is never exposed to hostile agents before
          the ComponentManager is set.
        </p>
      </s2>
      <s2 title="DefaultComponentSelector">
        <p>
          The DefaultComponentSelector again is simply a Hashtable selection of Components
          based on hints.  It gives the method <code>put</code> to populate the ComponentSelector.
          The ComponentSelector does not have the cascading feature of the ComponentManager,
          nor should it.  A ComponentSelector simply holds a number of Components that
          implement the same role--there really is no need to cascade.
        </p>
        <p>
          After the ComponentSelector is populated, you must put it in the ComponentManager.
          Please use the role of the Component you are selecting, not the role of the selector
          itself.  An acceptable convention is to add the "Selector" name to the end of the
          Role you are looking up.  Just be consistent.
        </p>
      </s2>
    </s1>
    <s1 title="The Container">
    	<p>
		The Container is the entity that manages your Components. It handles
		things like loading of configuration files, resolution of dependencies,
		component management, component isolation, and lifecycle support.
	</p>
	<p>
		The Container is not formalized in the form of an interface or contract
		within Avalon Framework, though it might be at some point in the future.
		The informal contract for the container is that it has the ability to
		host any fully avalon-framework compliant component. Most current containers
		place additional requirments on the component.
	</p>
	<p>
		For a list of containers implementations,
		<link href="reference-containers.xml">look here</link>.
	</p>
    </s1>
  </body>
  <footer>
    <legal>
      Copyright (c) @year@ The Jakarta Apache Project All rights reserved.
      $Revision: 1.1 $ $Date: 2006-08-08 23:17:20 $
    </legal>
  </footer>
</document>

